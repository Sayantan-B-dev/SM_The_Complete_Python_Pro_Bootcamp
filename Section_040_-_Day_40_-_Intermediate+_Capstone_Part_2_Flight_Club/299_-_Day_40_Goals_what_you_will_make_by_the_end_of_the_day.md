## STEP 0 — COMPLETE WORKFLOW OVERVIEW AND FILE RESPONSIBILITY MAP

### 0.1 End-to-End Runtime Workflow (ASCII Pipeline)

```
┌──────────────┐
│   main.py    │
│ Entry Point  │
└──────┬───────┘
       │
       │ invokes
       ▼
┌──────────────────────────┐
│ fetch_live_flights()     │
│ aviation_client.py      │
│ - Calls Aviationstack   │
│ - Normalizes flight data│
└──────┬──────────────────┘
       │ list[dict] flights
       │
       ▼
┌──────────────────────────┐
│ random_aviation_fact()  │
│ fun_facts.py            │
│ - Enriches each record  │
└──────┬──────────────────┘
       │ augmented flight dict
       │
       ▼
┌──────────────────────────┐
│ write_flight_record()   │
│ sheet_writer.py         │
│ - Sends data to Sheety  │
└──────┬──────────────────┘
       │ HTTP POST
       │
       ▼
┌──────────────────────────┐
│ Google Sheet (via API)  │
│ Persistent storage     │
└──────────────────────────┘
```

---

### 0.2 File-Level Tree With Purpose, Inputs, Outputs, Expectations

```
aviation_client.py
│
├─ fetch_live_flights(limit: int)
│   Input:
│     - limit: maximum number of live flights requested
│   External Dependency:
│     - AVIATIONSTACK_API_KEY
│     - https://api.aviationstack.com/v1/flights
│   Output:
│     - list[dict] of normalized flight telemetry
│   Expectations:
│     - Network availability
│     - API quota not exceeded
│     - Partial records tolerated with warnings
│
config.py
│
├─ Loads environment variables once
│   Input:
│     - .env file or OS environment
│   Output:
│     - Constants exposed to application
│   Expectations:
│     - All required secrets must exist
│     - Application fails fast if misconfigured
│
fun_facts.py
│
├─ random_aviation_fact()
│   Input:
│     - None
│   Output:
│     - str containing aviation trivia
│   Expectations:
│     - Deterministic randomness not required
│
sheet_writer.py
│
├─ write_flight_record(record: dict)
│   Input:
│     - Fully populated flight dictionary
│   External Dependency:
│     - Sheety REST API
│     - Bearer token authorization
│   Output:
│     - None (side-effect: persisted row)
│   Expectations:
│     - HTTP 2xx indicates success
│     - Non-2xx escalated as runtime errors
│
notification.py
│
├─ log(message: str)
├─ warn(message: str)
├─ error(message: str)
│   Input:
│     - Human-readable message
│   Output:
│     - Timestamped console output
│   Expectations:
│     - No silent execution paths
│
main.py
│
├─ main()
│   Role:
│     - Orchestrator and control flow manager
│   Output:
│     - Sequential ingestion and persistence
│   Expectations:
│     - Each failure is observable
```

---

## STEP 1 — DATA INGESTION FROM AVIATIONSTACK

The application initiates execution inside `main.py`, which immediately calls `fetch_live_flights`. This function constructs an HTTP GET request containing the API access key and record limit, sends it to the Aviationstack endpoint, validates the HTTP status, and parses the JSON payload. Each raw API object is transformed into a normalized internal dictionary that removes nested complexity and ensures consistent keys even when some telemetry is missing.

Key reliability behavior is intentional tolerance of incomplete live data, where missing telemetry produces warnings instead of fatal errors, ensuring the pipeline remains resilient under imperfect external data conditions.

---

## STEP 2 — DATA ENRICHMENT AND OBSERVABILITY

Once raw flight records are returned, `main.py` iterates sequentially through each dictionary and injects a human-readable aviation trivia string generated by `random_aviation_fact`. This enrichment step deliberately separates informational metadata from telemetry data, keeping the core flight model stable while allowing user-facing augmentation.

Each iteration logs progress using the centralized logging utility, ensuring traceability of which specific flight record is being processed at any moment, including its IATA identifier.

---

## STEP 3 — DATA PERSISTENCE THROUGH SHEETY

The enriched flight dictionary is passed into `write_flight_record`, which maps internal field names into the schema expected by the Google Sheet via Sheety. A POST request is constructed with explicit authorization headers and a strict timeout to prevent hanging network calls.

The function explicitly checks for HTTP success ranges instead of relying on assumptions, logging successful insertions while escalating failures through structured error messages followed by exception propagation. This ensures partial writes do not silently corrupt application state.

---

## STEP 4 — SYSTEM DESIGN EXPECTATIONS AND GUARANTEES

The system guarantees centralized configuration loading, deterministic execution order, explicit observability at every stage, and clean separation between ingestion, enrichment, persistence, and logging responsibilities. Failures are designed to surface early for configuration issues, gracefully for data irregularities, and loudly for persistence failures, producing a predictable and debuggable data pipeline suitable for extension into alerting, retries, or batch scheduling.
